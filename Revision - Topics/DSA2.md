
**Arrays**
- Append an element at the front of a list without built-in functions
- Check if an array is sorted with linear time complexity
- Combine two sorted arrays into a single sorted array in O(n) time
- Find the duplicate students
- Find the longest consecutive repeating characters in a string
- Find the occurrence of each character in a string using hash table
- Find the second longest word in a sentence
- Find the third largest element from an unsorted array
- Find two numbers in an array that add up to a target sum (Two Sum - LeetCode)
- Merge two sorted arrays
- Move zeroes to end
- Remove duplicates from an array in O(n)
- Remove the longest string from an array
- Reverse an array and its elements
- Sort an array of objects based on a property (e.g., .amount, age)
- Sort an array of students using merge sort
- Time complexity of getting an item by index from an array

***

**Linked Lists**
- Delete a specific node from a linked list
- Merge two sorted linked lists
- Remove middle element from a linked list
- Why use a linked list over an array

***

**Stack**
- Applications of stack (e.g., undo-redo operations)
- Check if a string is a palindrome using a stack
- Convert stack into a queue
- Delete a specific node from a stack
- Implement a stack that rejects duplicate values
- Implement a stack using a linked list
- Implement a stack using a queue
- Implement a stack with push, pop, and get max in O(1) time (MinStack)
- Operations: push, pop, peek, display
- Purpose of stack pointer
- Remove middle element from a stack
- Reverse a stack using recursion
- Reverse a string using a stack
- Sort a stack using a temporary stack
- Stack overflow vs underflow
- Stack vs array: when to use each
- Valid parentheses using stack (LeetCode #20)

***

**Queue**
- Applications of queues
- Bounded queues
- Circular queue implementation
- Circular queue with maximum length
- Convert queue into a stack
- Double-ended queue (deque) implementation
- Double-ended queue applications
- Implement a queue using a linked list
- Implement a queue using a stack
- Monotonic queue
- Operations: enqueue, dequeue, display
- Priority queue and its applications
- Reverse a queue
- Types of queues (e.g., circular, priority, double-ended)

***

**Hash Table**
- Applications of hash tables (e.g., database indexing)
- Collision handling: chaining with linked list
- Collision handling: double hashing
- Collision handling: linear probing vs quadratic probing
- Collision handling: open addressing
- Collision handling: separate chaining
- Difference between hash table and array
- Difference between hash table and hash set
- Find the first non-repeating character in a string using a hash table
- Find the frequency of characters in a string (e.g., 'Mississippi')
- Find the least occurred number using a hash table
- Find the uncommon elements from two arrays using a hash table
- Find two numbers that sum to a target (Two Sum) using a hash table in O(n)
- Hash table implementation with collision handling
- Hash table vs hash set
- Hashing vs encryption
- Load factor
- Popular hashing algorithms (e.g., SHA1, MD5, CRC32)
- Rehashing
- Remove duplicates from a string using a hash table
- Time complexity of hash table operations (search, insert, delete)
- Types of hash functions
- Valid anagram using a hash table

***

**Strings**
- Check if a string is balanced (valid parentheses)
- Convert the first character of a string to uppercase
- Find common characters from two strings
- Find the first missing number in an array of numbers
- Find the first non-repeating character in a string
- Find the subarray with the maximum sum (Kadane's algorithm)
- Reverse a string to its own place using a stack
- Sort a string using merge sort
- Sort a string using a stack
- Swap the first and last characters in a string
- Transform a string (e.g., 'APPLE' to 'A-pp-ppp-llll-eeeee')
- Why string is immutable

***

**Algorithms – Sorting**
- Best sorting algorithm for partially sorted small arrays
- Bubble sort: implementation, best-case time complexity, stability
- Insertion sort: implementation, time complexity
- In-place sorting
- Merge sort: implementation, time complexity, why preferred for linked lists
- Quick sort: implementation, time complexity, pivot selection, worst-case O(n^2)
- Selection sort: implementation, time complexity, disadvantages
- Sort an array alphabetically using QuickSort
- Sort an array of strings using merge sort
- Stable sorting: concept and examples
- Time complexity of all sorting algorithms
- Use cases of different sorting algorithms

***

**Algorithms – Searching**
- Linear Search
- Binary Search (standard implementation)
- Binary search in a rotated sorted array (find minimum)
- Time complexity analysis of searching algorithms

***

**Algorithms – Two Pointer Techniques**
- Fast and slow pointer: detect circle in a linked list
- Remove nth node from the end of a linked list
- Two Sum: find two numbers with a given sum in O(n)

***

**Algorithms – Other Topics**
- Buy and sell stock using sliding window
- Sliding window pattern
- Divide and conquer strategy
- Merge sort as a divide and conquer algorithm
- Quick sort as a divide and conquer algorithm
- Backtracking algorithms
- Check if an array is sorted in linear time
- Parenthesis checking using a stack

***

**Complexity Analysis**
- Best, average, and worst-case time complexity of sorting algorithms
- Omega and Theta notation
- Quick sort worst-case time complexity (O(n^2)) and pivot impact
- Time complexity of hash table operations
- Time complexity of merge sort (O(n log n))
- Time complexity of push element into a stack
- Understanding logarithmic values and functions
- Space complexity of merge sort vs quick sort
- Space complexity of recursive algorithms

***

**Memory Management**
- Jagged array
- Kilobyte vs kibibyte
- Memory pool
- Stack overflow vs heap overflow
- Virtual memory

***

**Practice Recommendations**
- Focus on practical coding and debugging
- Improve logic-building and coding speed
- Learn brute force and optimal solutions from YouTube (e.g., FreeCodeCamp)
- Practice problems from Blind 75 LeetCode list
- Refer to neetcode.io/practice for problem selection
- Solve problems without referring to solutions after learning
- Use print statements to understand code flow instead of AI tools
- Work on code optimization

***

**Miscellaneous**
- Applications of data structures: understand how they are used, not just memorize
- Build logic for solving array and linked list problems
- Debugging techniques
- Linear vs non-linear data structures
- Purpose of data structures in real-world applications

***